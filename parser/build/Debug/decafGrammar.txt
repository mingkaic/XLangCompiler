Type 				= ( T_INTTYPE | T_BOOLTYPE );
MethodType 			= ( T_VOID | Type );
ExternType 			= ( T_STRINGTYPE | MethodType );
Constant 			= ( T_INTCONSTANT | T_CHARCONSTANT | T_TRUE | T_FALSE );
Program 			= T_EXTERN T_CLASS T_ID T_LCB FieldDecls MethodDecls T_RCB;
Externs    			= { ExternDefn };
ExternDefn 			= T_EXTERN T_ID T_LPAREN [ { ExternType }+ ] T_RPAREN T_SEMICOLON;
FieldDecls 			= { FieldDecl };
FieldDecl  			= Type { T_ID | ArrayDecl }+ T_SEMICOLON;
FieldDecl  			= Type T_ID T_ASSIGN Constant T_SEMICOLON;
ArrayDecl 			= T_ID T_LSB T_INTTYPE T_RSB;
MethodDecls 		= { MethodDecl };
MethodDecl  		= MethodType T_ID T_LPAREN [ { Type T_ID }+ ] T_RPAREN Block;
Statements 			= Block;
Block 				= T_LCB VarDecls Statements T_RCB;
VarDecls 			= { VarDecl };
VarDecl  			= Type { T_ID }+ T_SEMICOLON;
Statement 			= Block;
Statement 			= Assign T_SEMICOLON;
Assign    			= Lvalue T_ASSIGN Expr;
Lvalue    			= T_ID | T_ID T_LSB Expr T_RSB;
Statement  			= MethodCall T_SEMICOLON;
MethodCall 			= T_ID T_LPAREN [ { MethodArg }+ ] T_RPAREN;
MethodArg  			= Expr | T_STRINGTYPE;
Statement 			= T_IF T_LPAREN Expr T_RPAREN Block [ T_ELSE Block ];
Statement 			=  T_WHILE T_LPAREN Expr T_RPAREN Block;
Statement 			= T_FOR T_LPAREN { Assign }+ T_SEMICOLON Expr T_SEMICOLON { Assign }+ T_RPAREN Block;
Statement 			= T_RETURN [ T_LPAREN [ Expr ] T_RPAREN ] T_SEMICOLON;
Statement 			= T_BREAK T_SEMICOLON;
Statement 			= T_CONTINUE T_SEMICOLON;
Expr 				= T_ID;
Expr 				= MethodCall;
Expr 				= Constant;
UnaryOperator 		= ( UnaryNot | UnaryMinus );
UnaryNot 			= T_NOT;
UnaryMinus 			= T_MINUS;
BinaryOperator 		= ( ArithmeticOperator | BooleanOperator );
ArithmeticOperator 	= ( T_PLUS | T_MINUS | T_MULT | T_DIV | T_LEFTSHIFT | T_RIGHTSHIFT | T_MOD );
BooleanOperator 	= ( T_EQ | T_NEQ | T_LT | T_LEQ | T_GT | T_GEQ | T_AND | T_OR );
Expr 				= Expr BinaryOperator Expr;
Expr 				= UnaryOperator Expr;
Expr 				= T_LPAREN Expr T_RPAREN;
Expr 				= T_ID T_LSB Expr T_RSB;
